index.html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Corazón Partículas Verde</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.141.0/build/three.min.js"></script>
  <!-- OrbitControls (misma versión) -->
  <script src="https://unpkg.com/three@0.141.0/examples/js/controls/OrbitControls.js"></script>
  <!-- GSAP -->
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const countBorder = 1500;
    const countFill = 800;
    const borderPositions = new Float32Array(countBorder * 3);
    const fillPositions = new Float32Array(countFill * 3);
    const borderTargets = [];
    const fillTargets = [];
    const scale = 0.09;

    // --------------------------
    // Borde
    // --------------------------
    for (let i = 0; i < countBorder; i++) {
      const t = Math.random() * Math.PI * 2;
      const x = 16 * Math.pow(Math.sin(t), 3) * scale;
      const y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * scale;
      const z = (Math.random() - 0.5) * 0.1;

      borderPositions[i*3] = (Math.random() - 0.5) * 8;
      borderPositions[i*3+1] = (Math.random() - 0.5) * 8;
      borderPositions[i*3+2] = (Math.random() - 0.5) * 8;

      borderTargets.push({ x, y, z });
    }

    // --------------------------
    // Relleno
    // --------------------------
    function insideHeart(x, y) {
      return (Math.pow(x*x + y*y - 1, 3) - x*x*y*y*y <= 0);
    }

    for (let i = 0; i < countFill; i++) {
      let x, y;
      do {
        x = (Math.random() * 2 - 1) * 1.5;
        y = (Math.random() * 2 - 1) * 1.5;
      } while (!insideHeart(x, y));

      const posX = x * 1.2 * scale * 16/15;
      const posY = y * 1.2 * scale * 13/15;
      const z = (Math.random() - 0.5) * 0.15;

      fillPositions[i*3] = (Math.random() - 0.5) * 8;
      fillPositions[i*3+1] = (Math.random() - 0.5) * 8;
      fillPositions[i*3+2] = (Math.random() - 0.5) * 8;

      fillTargets.push({ x: posX, y: posY, z });
    }

    const borderGeometry = new THREE.BufferGeometry();
    borderGeometry.setAttribute("position", new THREE.BufferAttribute(borderPositions, 3));

    const fillGeometry = new THREE.BufferGeometry();
    fillGeometry.setAttribute("position", new THREE.BufferAttribute(fillPositions, 3));

    const borderMaterial = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.11 });
    const fillMaterial = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.05, transparent: true, opacity: 0.5 });

    const borderHeart = new THREE.Points(borderGeometry, borderMaterial);
    const fillHeart = new THREE.Points(fillGeometry, fillMaterial);
    scene.add(borderHeart);
    scene.add(fillHeart);

    camera.position.z = 7;
    new THREE.OrbitControls(camera, renderer.domElement);

    // Animaciones
    function toHeart() {
      const borderPos = borderHeart.geometry.attributes.position.array;
      const fillPos = fillHeart.geometry.attributes.position.array;

      for (let i = 0; i < countBorder; i++) {
        const idx = i * 3;
        gsap.to(borderPos, {
          [idx]: borderTargets[i].x,
          [idx+1]: borderTargets[i].y,
          [idx+2]: borderTargets[i].z,
          duration: 2,
          delay: Math.random() * 1.2,
          ease: "power2.inOut",
          onUpdate: () => borderHeart.geometry.attributes.position.needsUpdate = true
        });
      }
      for (let i = 0; i < countFill; i++) {
        const idx = i * 3;
        gsap.to(fillPos, {
          [idx]: fillTargets[i].x,
          [idx+1]: fillTargets[i].y,
          [idx+2]: fillTargets[i].z,
          duration: 2,
          delay: Math.random() * 1.2,
          ease: "power2.inOut",
          onUpdate: () => fillHeart.geometry.attributes.position.needsUpdate = true
        });
      }
    }

    function toCenter() {
      const borderPos = borderHeart.geometry.attributes.position.array;
      const fillPos = fillHeart.geometry.attributes.position.array;

      for (let i = 0; i < countBorder; i++) {
        const idx = i * 3;
        gsap.to(borderPos, {
          [idx]: 0, [idx+1]: 0, [idx+2]: 0,
          duration: 2,
          delay: Math.random() * 1.2,
          ease: "power2.inOut",
          onUpdate: () => borderHeart.geometry.attributes.position.needsUpdate = true
        });
      }
      for (let i = 0; i < countFill; i++) {
        const idx = i * 3;
        gsap.to(fillPos, {
          [idx]: 0, [idx+1]: 0, [idx+2]: 0,
          duration: 2,
          delay: Math.random() * 1.2,
          ease: "power2.inOut",
          onUpdate: () => fillHeart.geometry.attributes.position.needsUpdate = true
        });
      }
    }

    let showingHeart = false;

    // 🔥 Mostrar el corazón apenas carga
    toHeart();

    // 🔥 Interacción por click/tap
    document.body.addEventListener("click", () => {
      if (showingHeart) {
        toCenter();
      } else {
        toHeart();
      }
      showingHeart = !showingHeart;
    });

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
